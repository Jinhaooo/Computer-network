# HTTP 和 HTTPS
## HTTP和HTTPS的区别  
1.HTTPS在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。  
2.HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。  
3.两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。  
4.HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。  
<img width="596" height="275" alt="image" src="https://github.com/user-attachments/assets/6254fad3-e924-47e1-8462-87c34303c0e3" />  

## HTTPS是如何解决HTTP的风险的？
### 1.混合加密
通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。  
<img width="613" height="471" alt="image" src="https://github.com/user-attachments/assets/3a1a45d5-00eb-418d-a88e-8ab08f47f1f3" />  
HTTPS采用的是对称加密和非对称加密的混合加密方式：  
在通信建立前，采用非对称加密的方式交换密匙。  
在通信过程中全部使用对称加密的方式加密明文数据。  
采用非对称加密的原因：  
对称加密只使用一个密匙，交换速度快，但是密匙分发的过程中不安全。而非对称加密使用两个密匙，公匙和私匙，密匙分发的安全但是速度慢。  
所以我们就用非对称加密来负责密匙分发，而用对称加密来进行数据加密，这就是非对称加密的优雅之处。  

### 2.摘要算法 + 数字签名
为了保证传输数据不被篡改，我们需要对内容加一个指纹，然后和内容一起传给对方，对方收到后，先是根据内容也计算出一个指纹，如果指纹和内容相同，那就说明没有被篡改。  
那么，在计算机里会用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。  
<img width="1276" height="636" alt="image" src="https://github.com/user-attachments/assets/f34197d7-4141-42ce-a967-a8b60982ccda" />  
但是如果中间人替换了整个内容+指纹，客户端就无法识别这个消息是否还是由服务端发送的了，为了避免这种情况，计算机会用非对称加密算法来解决。  
这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。  
流程的不同，意味着目的也不相同：  
公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；  
私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。  
非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。  
<img width="1282" height="652" alt="image" src="https://github.com/user-attachments/assets/1a6f7cdf-7f9f-4040-84af-af347151027b" />  
私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。  

### 3.数字证书
现在还缺少身份验证的环节，如果有中间人直接伪造了一套公私匙呢？客户端通过公匙解密能知道数据没有被篡改，但是其实数据本身就是假的！为了解决这个冒充的问题，HTTPS采用了数字证书。  
也就是将公匙注册到CA（权威认证机构）中，就能实现身份的验证。  
<img width="779" height="577" alt="image" src="https://github.com/user-attachments/assets/c12ea6ce-3373-4252-a0bb-b7ac3139d0f1" />

## HTTPS是如何建立连接的？
SSL/TLS协议基本流程：  
客户端向服务器索要并验证服务器的公匙。  
双方协商生成会话密匙。  
双方采用会话密匙进行加密通信。  
前两步也就是SSL/TLS的建立过程，也就是TLS握手阶段。TLS的握手阶段涉及四次通信，使用不同的密匙交换算法，TLS握手阶段也不一样，目前常用的有RSA算法和ECDHE算法。  
RSA算法：  
<img width="1545" height="2807" alt="image" src="https://github.com/user-attachments/assets/737ff3bb-a4b8-4dd8-98c8-f8fac2074944" />  
1. ClientHello  
首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。  
在这一步，客户端主要向服务器发送以下信息：  
（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。  
（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。  
（3）客户端支持的密码套件列表，如 RSA 加密算法。  

2. ServerHello
服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：  
（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。  
（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。  
（3）确认的密码套件列表，如 RSA 加密算法。  
（4）服务器的数字证书。  

3. 客户端回应  
客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。  
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。  
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。  
（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。  
上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。  
服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应  
服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。  
然后，向客户端发送最后的信息：  
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。  
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。  

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。  





